# Aliases
alias t='tmux'
alias ta='tmux attach'
alias n='nvim'
alias inc='nvim ~/.nixpkgs/src/zsh/zshrc'
alias incc='source ~/.zshrc'
alias dod="cd ~/.nixpkgs"
alias lg="lazygit"
alias s="ssh"
alias ldo='lazydocker'
alias nd="nix develop -c $SHELL"
alias ..="cd ../"
alias ...="cd ../.."
alias ls="ls --color=tty"
alias mcu="make clean && make up"
alias me="make enter"
alias lkj="nix develop $HOME/.nixpkgs#python39 -c $SHELL"

# Environment Variables
export EDITOR='nvim'
export VISUAL='nvim'
export PAGER='less -S'
# I get issues all the time with kitty and remote hosts that don't understand
# it. Default to this, customize when needed
export TERM='xterm-256color'
export COOKIECUTTER_CONFIG="$HOME/.config/cookiecutter/config.yml"
# For some reason, docker client is expecting in a different location
# (unix:///run/user/1000/docker.sock) but hardcode for now
export DOCKER_HOST="unix:///run/docker.sock"

# Additional includes
source "$HOME/.config/zsh/git.zsh"

# Load keychain on startup
eval $(keychain --eval --quiet id_rsa)

# Use vim to edit longer commands
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

# Jump to a project diredtory
j() { # Jump to project code
    PROJ=$(find "$HOME/Work" -mindepth 2 -maxdepth 2 -type d -name "$1")
    if [[ -d "$PROJ/code" ]]; then
        cd "$PROJ/code"
    else
        echo "$PROJ/code does not exist"
    fi
}

# Launch a new tmux session around an existing project
tlo() {
    if [[ -z "$1" ]]; then
        return
    fi
    local PROJS=($(find "$HOME"/Work/* -mindepth 1 -maxdepth 1 -type d))
    local PROJ_NAME=''
    local PROJ_DIR=''
    for dir in "${PROJS[@]}"; do
        if [[ $(basename "$dir") == "$1" ]]; then
            PROJ_NAME=$(basename "$dir")
            PROJ_DIR="$dir/code"
            tmux new-session -c "${PROJ_DIR}" -s "${PROJ_NAME}"
            return
        fi
    done
    echo "Project '${1}' was not found"
}

cwh() { cat $(which $1) }

rmresult() {
        TMP_STORE_PATH=$(readlink result)
        rm -rf result
        nix-store --delete "${TMP_STORE_PATH}"
}

nrs() {
    if [[ $(uname -s) == "Linux" ]]; then
        sudo -i nixos-rebuild switch
    elif [[ $(uname -s) == "Darwin" ]]; then
        darwin-rebuild switch --flake ~/.nixpkgs
    else
        echo "unknown platform"
    fi
}

nixc() {
    if [[ $(hostname) == "Codys-MacBook-Pro-Work.local" ]]; then
        nvim ~/.nixpkgs/hosts/macbookwork/darwin-configuration.nix
    elif [[ $(hostname) == "enigma" ]]; then
        nvim ~/.nixpkgs/hosts/enigma/configuration.nix
    elif [[ $(hostname) == "Codys-MacBook-Pro.local" ]]; then
        nvim ~/.nixpkgs/hosts/macbook/darwin-configuration.nix
    else
        echo "unknown host"
    fi
}

jp() { # Jump to project code in parsely
    PROJ=$(find "$HOME/Work/parsely/engineering/code" -mindepth 1 -maxdepth 1 -type d -name "$1")
    cd "$PROJ"
}

# A lazy command that will wait for me to press enter and then rebuild the my nix config.
# Makes reloads much faster, usually just runs in a tmux pane.
rebuildr() {
    while true; do
        echo -n "Press enter to continue"
        read -r REPLY
        if [[ $REPLY == "q" ]]; then
            break
        fi
        nrs
    done
}

# Custom autocompletes
compdef j=projects_listing
compdef jp=projects_listing_engineering
compdef tlo=projects_listing

